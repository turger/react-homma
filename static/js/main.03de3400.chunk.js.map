{"version":3,"sources":["Timetable.js","requests.js","App.js","serviceWorker.js","index.js"],"names":["Timetable","toHhMm","milliseconds","departureTime","Date","hours","getUTCHours","minutes","getUTCMinutes","slice","stopsData","this","props","console","log","className","map","stop","key","gtfsId","name","stoptimesWithoutPatterns","stopTime","trip","route","realtimeArrival","mode","shortName","Component","request","require","getCurrentTimestamp","Math","round","getTime","getStopsData","startTime","Promise","resolve","post","url","headers","body","err","httpResponse","error","JSON","parse","App","a","response","setState","data","stops","state","setInterval","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"+bA4CeA,G,kNAxCbC,OAAS,SAACC,GACR,IAAMC,EAAgB,IAAIC,KAAoB,IAAfF,GACzBG,EAAQF,EAAcG,cACtBC,GAAW,IAAMJ,EAAcK,iBAAiBC,OAAO,GAC7D,MAAM,GAAN,OAAUJ,EAAV,YAAmBE,I,wEAGX,IAAD,OACCG,EAAcC,KAAKC,MAAnBF,UACR,OAAKA,GACLG,QAAQC,IAAI,YAAYJ,GAGtB,yBAAKK,UAAU,aACZL,EAAUM,IAAI,SAAAC,GAAI,OACjB,yBAAKF,UAAU,iBAAiBG,IAAKD,EAAKE,QACxC,4BAAKF,EAAKG,MACV,+BACE,+BACE,4BACE,8CACA,iDAGJ,+BACIH,EAAKI,yBAAyBL,IAAI,SAAAM,GAAQ,OAC1C,wBAAIJ,IAAG,UAAKI,EAASC,KAAKC,MAAML,OAAzB,YAAmCG,EAASG,kBACjD,4BAAKH,EAASC,KAAKC,MAAME,KAAzB,IAAgCJ,EAASC,KAAKC,MAAMG,WACpD,4BAAK,EAAK1B,OAAOqB,EAASG,4BAnBnB,S,GAVHG,cCHlBC,G,OAAUC,EAAQ,MAElBC,EAAsB,WAC1B,OAAOC,KAAKC,OAAM,IAAI7B,MAAO8B,UAAY,MAG9BC,EAAe,eAACC,EAAD,uDAAaL,IAAb,OAAuC,IAAIM,QAAQ,SAAAC,GAE7ET,EAAQU,KACN,CACEC,IAAI,kEACJC,QAAS,CAAE,eAAgB,uBAC3BC,KAAK,gBAAD,OALK,iCAKL,sIAIqBN,EAJrB,+ZAqBN,SAA0BO,EAAKC,EAAcF,GAC3C,GAAIC,EACF,OAAO9B,QAAQgC,MAAM,4BAA6BF,GAEpDL,EAAQQ,KAAKC,MAAML,SCHVM,E,YA5Bb,aAAe,IAAD,8BACV,+CAWJb,aAZc,qBAYC,4BAAAc,EAAA,qEACUd,IADV,OACPe,EADO,OAEbrC,QAAQC,IAAI,YAAaoC,GACzB,EAAKC,SAAS,CAACzC,UAAWwC,EAASE,KAAKC,QAH3B,yCAVX,EAAKC,MAAQ,CAAE5C,UAAW,IAFhB,E,oNAMNC,KAAKwB,e,OACXoB,YAAW,qBAAC,sBAAAN,EAAA,qEACJ,EAAKd,eADD,yCAER,K,mIAUJ,OACE,yBAAKpB,UAAU,OACb,yCACA,kBAAC,EAAD,CAAWL,UAAWC,KAAK2C,MAAM5C,iB,GAvBvBkB,aCOE4B,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC,iB","file":"static/js/main.03de3400.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport './Timetable.css'\n\nclass Timetable extends Component {\n  toHhMm = (milliseconds) => {\n    const departureTime = new Date(milliseconds * 1000)\n    const hours = departureTime.getUTCHours()\n    const minutes = ('0' + departureTime.getUTCMinutes()).slice(-2)\n    return `${hours}:${minutes}`\n  }\n\n  render() {\n    const { stopsData } = this.props\n    if (!stopsData) return null // to prevent errors while request to HSL api is being made\n    console.log('stopsData',stopsData)\n\n    return (\n      <div className=\"Timetable\">\n        {stopsData.map(stop =>\n          <div className=\"Timetable_stop\" key={stop.gtfsId}>\n            <h2>{stop.name}</h2>\n            <table>\n              <thead>\n                <tr>\n                  <th>Kulkuväline</th>\n                  <th>Lähtöaika</th>\n                </tr>\n              </thead>\n              <tbody>\n                {(stop.stoptimesWithoutPatterns.map(stopTime =>\n                  <tr key={`${stopTime.trip.route.gtfsId}-${stopTime.realtimeArrival}`}>\n                    <td>{stopTime.trip.route.mode} {stopTime.trip.route.shortName}</td>\n                    <td>{this.toHhMm(stopTime.realtimeArrival)}</td>\n                  </tr>\n                ))}\n              </tbody>\n            </table>\n          </div>\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Timetable\n","const request = require('request')\n\nconst getCurrentTimestamp = () => {\n  return Math.round(new Date().getTime() / 1000)\n}\n\nexport const getStopsData = (startTime = getCurrentTimestamp()) => new Promise(resolve => {\n  const stopIds = `[\"HSL:1310102\", \"HSL:1020171\"]` // in here add your own stop or stops\n  request.post(\n    {\n      url:'https://api.digitransit.fi/routing/v1/routers/hsl/index/graphql',\n      headers: { 'Content-Type': 'application/graphql' },\n      body: `{ stops(ids: ${stopIds}) {\n                name\n                gtfsId\n                stoptimesWithoutPatterns(\n                  startTime:\"${startTime}\",\n                  timeRange: 180000,\n                  numberOfDepartures:10\n                ) {\n                  realtimeArrival\n                  trip {\n                    route {\n                      gtfsId\n                      longName\n                      shortName\n                      mode\n                    }\n                  }\n                }\n              }\n            }`\n    },\n    function optionalCallback(err, httpResponse, body) {\n      if (err) {\n        return console.error('Stops data upload failed:', err);\n      }\n      resolve(JSON.parse(body))\n    }\n  )\n})\n","import React, {Component} from 'react'\nimport Timetable from './Timetable'\nimport './App.css'\nimport {getStopsData} from './requests'\n\nclass App extends Component {\n  constructor() {\n      super()\n      this.state = { stopsData: [] }\n    }\n\n  async componentDidMount() {\n    await this.getStopsData()\n    setInterval(async () => {\n      await this.getStopsData()\n    } , 60000)\n  }\n\n  getStopsData = async () => {\n    const response = await getStopsData()\n    console.log('Response:', response) // open chrome devtools console panel Command+Option+J to see this output\n    this.setState({stopsData: response.data.stops})\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <h1>Aikataulu</h1>\n        <Timetable stopsData={this.state.stopsData}/>\n      </div>\n    )\n  }\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}